一.ARM汇编指令学习
=======================算数类
1.mon
2.mvn
3.ubs  减法     先保存再编译bulidall
被减数不能为立即数
4.add 加法
5.and  逻辑与
6.bic 位清除
====================比较类
7.cmp 比较
不会把值存下来，但是会影响CPSR寄存器
<0 N位置1
=0 Z位置1
8.tst 按位与
=0 Z位置1
====================跳转指令
9.b
bgt branch1

10.bl
调用函数时，bl能够保存开始跳转的地址，保存在lr寄存器里面
mov pc, lr
=====================移位指令
11.逻辑.算数左移
mov r0, r1，lsl #1
12.右移
mov r0, r1, lsr #1
13.ror 循环右移
mov r0, r1, ror #1
======================程序状态寄存器
14.mrs 从状态寄存器cpsr赋值到普通寄存器
mrs r0， cpsr
15.msr 普通寄存器到状态寄存器cpsr
msr cpsr， r0
======================存储器访问指令
16.str
mov r1, #0x30000000
str r0, [r1]  把寄存器里面的值保存到存储器
把r0的值保存到地址0x30000000
17.ldr
mov r1, #0x3000000
ldr r0, [r1] 把存储器里面的值保存到寄存器
也就是把地址0x30000000里面的值保存到r0
=====================位清除
bic r0, r0, #0b1011  把 0，1，3 位置0
orr r0, r0, #0b1011  把 0，1，3 位置1
======================================
二.ARM伪指令
mov 机械码最后一段12位，但是只能用8位，还有4位是用来存储左移右移的
1.arm机器码
arm-linux-objdump -D -S start.S 可以查看机器码
查找学习文档，instruction set
==================
2.伪指令
定义类伪指令
查看一个elf文件的详细内容 arm-linux-readelf -a start.elf 能够看到每条语句的地址等
.global 定义一个全局参数  .global _start 
.data 数据段 表明数据段的开始
.equ 宏定义
.ascii 定义一个字符串
.byte  定义一个字节大小的数据
.word 定义四个个字节的大小  一个字   因为是32位的嵌入式操作系统
.align 使地址4字节对齐
操作类伪指令
nop 空指令，延迟 mov r0， r0
ldr 跟从寄存器访问存储器的指令写法一样，由于mov只能存储8位，ldr r0, =0xfff可以存储大于8位的数据
========================
三.协处理器访问指令
最多支持16个协处理器，CP15是最重要的协处理器
mcr p15,0,r1,
mrc p15,0,r1,c0,c0,0 p15的寄存器0 ID code 是只读的，不能使用mcr指令





















